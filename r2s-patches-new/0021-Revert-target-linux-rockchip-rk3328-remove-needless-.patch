From 37693581e215171c8051c39f8f84114e560494f2 Mon Sep 17 00:00:00 2001
From: Lawrence-Tang <tangzongsheng@gmail.com>
Date: Sat, 22 Feb 2020 20:54:08 +0800
Subject: [PATCH 21/53] Revert "target/linux/rockchip-rk3328: remove needless
 patch"

This reverts commit 2b0b53858abe55fc0677d7dddef8d70466912365.
---
 ...x-add-support-for-rgmii-internal-delay-mo.patch | 139 +++++++++++++++++++++
 ...hunderx-workaround-BGX-TX-Underflow-issue.patch | 110 ++++++++++++++++
 2 files changed, 249 insertions(+)
 create mode 100644 target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch
 create mode 100644 target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch

diff --git a/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch b/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch
new file mode 100644
index 0000000000..efd13da5ec
--- /dev/null
+++ b/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch
@@ -0,0 +1,139 @@
+From 69a99101748bb1bdb2730393ef48bc152c4d244a Mon Sep 17 00:00:00 2001
+From: Tim Harvey <tharvey@gateworks.com>
+Date: Tue, 12 Dec 2017 12:49:55 -0800
+Subject: [PATCH] net: thunderx: add support for rgmii internal delay modes
+
+The XCV_DLL_CTL is being configured with the assumption that
+phy-mode is rgmii-txid (PHY_INTERFACE_MODE_RGMII_TXID) which is not always
+the case.
+
+This patch parses the phy-mode property and uses it to configure CXV_DLL_CTL
+properly.
+
+Signed-off-by: Tim Harvey <tharvey@gateworks.com>
+---
+ drivers/net/ethernet/cavium/thunder/thunder_bgx.c | 13 +++++++---
+ drivers/net/ethernet/cavium/thunder/thunder_bgx.h |  2 +-
+ drivers/net/ethernet/cavium/thunder/thunder_xcv.c | 31 ++++++++++++++++++-----
+ 3 files changed, 35 insertions(+), 11 deletions(-)
+
+--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
++++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+@@ -55,6 +55,7 @@ struct bgx {
+ 	struct pci_dev		*pdev;
+ 	bool                    is_dlm;
+ 	bool                    is_rgx;
++	int			phy_mode;
+ };
+ 
+ static struct bgx *bgx_vnic[MAX_BGX_THUNDER];
+@@ -841,12 +842,12 @@ static void bgx_poll_for_link(struct wor
+ 	queue_delayed_work(lmac->check_link, &lmac->dwork, HZ * 2);
+ }
+ 
+-static int phy_interface_mode(u8 lmac_type)
++static int phy_interface_mode(struct bgx *bgx, u8 lmac_type)
+ {
+ 	if (lmac_type == BGX_MODE_QSGMII)
+ 		return PHY_INTERFACE_MODE_QSGMII;
+ 	if (lmac_type == BGX_MODE_RGMII)
+-		return PHY_INTERFACE_MODE_RGMII;
++		return bgx->phy_mode;
+ 
+ 	return PHY_INTERFACE_MODE_SGMII;
+ }
+@@ -912,7 +913,8 @@ static int bgx_lmac_enable(struct bgx *b
+ 
+ 		if (phy_connect_direct(&lmac->netdev, lmac->phydev,
+ 				       bgx_lmac_handler,
+-				       phy_interface_mode(lmac->lmac_type)))
++				       phy_interface_mode(bgx,
++							  lmac->lmac_type)))
+ 			return -ENODEV;
+ 
+ 		phy_start_aneg(lmac->phydev);
+@@ -1287,6 +1289,8 @@ static int bgx_init_of_phy(struct bgx *b
+ 		bgx->lmac[lmac].lmacid = lmac;
+ 
+ 		phy_np = of_parse_phandle(node, "phy-handle", 0);
++		if (phy_np)
++			bgx->phy_mode = of_get_phy_mode(phy_np);
+ 		/* If there is no phy or defective firmware presents
+ 		 * this cortina phy, for which there is no driver
+ 		 * support, ignore it.
+@@ -1390,7 +1394,6 @@ static int bgx_probe(struct pci_dev *pde
+ 		bgx->max_lmac = 1;
+ 		bgx->bgx_id = MAX_BGX_PER_CN81XX - 1;
+ 		bgx_vnic[bgx->bgx_id] = bgx;
+-		xcv_init_hw();
+ 	}
+ 
+ 	/* On 81xx all are DLMs and on 83xx there are 3 BGX QLMs and one
+@@ -1407,6 +1410,8 @@ static int bgx_probe(struct pci_dev *pde
+ 	if (err)
+ 		goto err_enable;
+ 
++	if (bgx->is_rgx)
++		xcv_init_hw(bgx->phy_mode);
+ 	bgx_init_hw(bgx);
+ 
+ 	/* Enable all LMACs */
+--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
++++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
+@@ -226,7 +226,7 @@ void bgx_lmac_internal_loopback(int node
+ void bgx_lmac_get_pfc(int node, int bgx_idx, int lmacid, void *pause);
+ void bgx_lmac_set_pfc(int node, int bgx_idx, int lmacid, void *pause);
+ 
+-void xcv_init_hw(void);
++void xcv_init_hw(int phy_mode);
+ void xcv_setup_link(bool link_up, int link_speed);
+ 
+ u64 bgx_get_rx_stats(int node, int bgx_idx, int lmac, int idx);
+--- a/drivers/net/ethernet/cavium/thunder/thunder_xcv.c
++++ b/drivers/net/ethernet/cavium/thunder/thunder_xcv.c
+@@ -65,7 +65,7 @@ MODULE_LICENSE("GPL v2");
+ MODULE_VERSION(DRV_VERSION);
+ MODULE_DEVICE_TABLE(pci, xcv_id_table);
+ 
+-void xcv_init_hw(void)
++void xcv_init_hw(int phy_mode)
+ {
+ 	u64  cfg;
+ 
+@@ -81,12 +81,31 @@ void xcv_init_hw(void)
+ 	/* Wait for DLL to lock */
+ 	msleep(1);
+ 
+-	/* Configure DLL - enable or bypass
+-	 * TX no bypass, RX bypass
+-	 */
++	/* enable/bypass DLL providing MAC based internal TX/RX delays */
+ 	cfg = readq_relaxed(xcv->reg_base + XCV_DLL_CTL);
+-	cfg &= ~0xFF03;
+-	cfg |= CLKRX_BYP;
++	cfg &= ~0xffff00;
++	switch (phy_mode) {
++	/* RX and TX delays are added by the MAC */
++	case PHY_INTERFACE_MODE_RGMII:
++		break;
++	/* internal RX and TX delays provided by the PHY */
++	case PHY_INTERFACE_MODE_RGMII_ID:
++		cfg |= CLKRX_BYP;
++		cfg |= CLKTX_BYP;
++		break;
++	/* internal RX delay provided by the PHY, the MAC
++	 * should not add an RX delay in this case
++	 */
++	case PHY_INTERFACE_MODE_RGMII_RXID:
++		cfg |= CLKRX_BYP;
++		break;
++	/* internal TX delay provided by the PHY, the MAC
++	 * should not add an TX delay in this case
++	 */
++	case PHY_INTERFACE_MODE_RGMII_TXID:
++		cfg |= CLKRX_BYP;
++		break;
++	}
+ 	writeq_relaxed(cfg, xcv->reg_base + XCV_DLL_CTL);
+ 
+ 	/* Enable compensation controller and force the
diff --git a/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch b/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch
new file mode 100644
index 0000000000..ef7aef3a8a
--- /dev/null
+++ b/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch
@@ -0,0 +1,110 @@
+From b1e7791e688620c9bb8476ac2d0bc99abeb7f825 Mon Sep 17 00:00:00 2001
+From: Tim Harvey <tharvey@gateworks.com>
+Date: Fri, 29 Dec 2017 16:48:04 -0800
+Subject: [PATCH] net: thunderx: workaround BGX TX Underflow issue
+
+While it is not yet understood why a TX underflow can easily occur
+for SGMII interfaces resulting in a TX wedge. It has been found that
+disabling/re-enabling the LMAC resolves the issue.
+
+Signed-off-by: Tim Harvey <tharvey@gateworks.com>
+---
+ drivers/net/ethernet/cavium/thunder/thunder_bgx.c | 54 +++++++++++++++++++++++
+ drivers/net/ethernet/cavium/thunder/thunder_bgx.h |  9 ++++
+ 2 files changed, 63 insertions(+)
+
+--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
++++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
+@@ -1344,6 +1344,54 @@ static int bgx_init_phy(struct bgx *bgx)
+ 	return bgx_init_of_phy(bgx);
+ }
+ 
++static irqreturn_t bgx_intr_handler(int irq, void *data)
++{
++	struct bgx *bgx = (struct bgx *)data;
++	struct device *dev = &bgx->pdev->dev;
++	u64 status, val;
++	int lmac;
++
++	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
++		status = bgx_reg_read(bgx, lmac, BGX_GMP_GMI_TXX_INT);
++		if (status & GMI_TXX_INT_UNDFLW) {
++			dev_err(dev, "BGX%d lmac%d UNDFLW\n", bgx->bgx_id,
++				lmac);
++			val = bgx_reg_read(bgx, lmac, BGX_CMRX_CFG);
++			val &= ~CMR_EN;
++			bgx_reg_write(bgx, lmac, BGX_CMRX_CFG, val);
++			val |= CMR_EN;
++			bgx_reg_write(bgx, lmac, BGX_CMRX_CFG, val);
++		}
++		/* clear interrupts */
++		bgx_reg_write(bgx, lmac, BGX_GMP_GMI_TXX_INT, status);
++	}
++
++	return IRQ_HANDLED;
++}
++
++static int bgx_register_intr(struct pci_dev *pdev)
++{
++	struct bgx *bgx = pci_get_drvdata(pdev);
++	struct device *dev = &pdev->dev;
++	int num_vec, ret;
++	char irq_name[32];
++
++	/* Enable MSI-X */
++	num_vec = pci_msix_vec_count(pdev);
++	ret = pci_alloc_irq_vectors(pdev, num_vec, num_vec, PCI_IRQ_MSIX);
++	if (ret < 0) {
++		dev_err(dev, "Req for #%d msix vectors failed\n", num_vec);
++		return 1;
++	}
++	sprintf(irq_name, "BGX%d", bgx->bgx_id);
++	ret = request_irq(pci_irq_vector(pdev, GMPX_GMI_TX_INT),
++		bgx_intr_handler, 0, irq_name, bgx);
++	if (ret)
++		return 1;
++
++	return 0;
++}
++
+ static int bgx_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+ {
+ 	int err;
+@@ -1414,6 +1462,8 @@ static int bgx_probe(struct pci_dev *pde
+ 		xcv_init_hw(bgx->phy_mode);
+ 	bgx_init_hw(bgx);
+ 
++	bgx_register_intr(pdev);
++
+ 	/* Enable all LMACs */
+ 	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
+ 		err = bgx_lmac_enable(bgx, lmac);
+@@ -1424,6 +1474,10 @@ static int bgx_probe(struct pci_dev *pde
+ 				bgx_lmac_disable(bgx, --lmac);
+ 			goto err_enable;
+ 		}
++
++		/* enable TX FIFO Underflow interrupt */
++		bgx_reg_modify(bgx, lmac, BGX_GMP_GMI_TXX_INT_ENA_W1S,
++			       GMI_TXX_INT_UNDFLW);
+ 	}
+ 
+ 	return 0;
+--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
++++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
+@@ -179,6 +179,15 @@
+ #define BGX_GMP_GMI_TXX_BURST		0x38228
+ #define BGX_GMP_GMI_TXX_MIN_PKT		0x38240
+ #define BGX_GMP_GMI_TXX_SGMII_CTL	0x38300
++#define BGX_GMP_GMI_TXX_INT		0x38500
++#define BGX_GMP_GMI_TXX_INT_W1S		0x38508
++#define BGX_GMP_GMI_TXX_INT_ENA_W1C	0x38510
++#define BGX_GMP_GMI_TXX_INT_ENA_W1S	0x38518
++#define  GMI_TXX_INT_PTP_LOST			BIT_ULL(4)
++#define  GMI_TXX_INT_LATE_COL			BIT_ULL(3)
++#define  GMI_TXX_INT_XSDEF			BIT_ULL(2)
++#define  GMI_TXX_INT_XSCOL			BIT_ULL(1)
++#define  GMI_TXX_INT_UNDFLW			BIT_ULL(0)
+ 
+ #define BGX_MSIX_VEC_0_29_ADDR		0x400000 /* +(0..29) << 4 */
+ #define BGX_MSIX_VEC_0_29_CTL		0x400008
-- 
2.14.1.windows.1

