From 7c7513c5a2a736f448e1cd2e81049d270d830cbf Mon Sep 17 00:00:00 2001
From: kongfl888 <kongfl888@outlook.com>
Date: Tue, 7 Jul 2020 05:27:31 +0800
Subject: [PATCH 50/55] Remove thunderx patch.

---
 ...x-add-support-for-rgmii-internal-delay-mo.patch | 139 ---------------------
 ...hunderx-workaround-BGX-TX-Underflow-issue.patch | 110 ----------------
 2 files changed, 249 deletions(-)
 delete mode 100644 target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch
 delete mode 100644 target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch

diff --git a/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch b/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch
deleted file mode 100644
index efd13da5ec..0000000000
--- a/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-add-support-for-rgmii-internal-delay-mo.patch
+++ /dev/null
@@ -1,139 +0,0 @@
-From 69a99101748bb1bdb2730393ef48bc152c4d244a Mon Sep 17 00:00:00 2001
-From: Tim Harvey <tharvey@gateworks.com>
-Date: Tue, 12 Dec 2017 12:49:55 -0800
-Subject: [PATCH] net: thunderx: add support for rgmii internal delay modes
-
-The XCV_DLL_CTL is being configured with the assumption that
-phy-mode is rgmii-txid (PHY_INTERFACE_MODE_RGMII_TXID) which is not always
-the case.
-
-This patch parses the phy-mode property and uses it to configure CXV_DLL_CTL
-properly.
-
-Signed-off-by: Tim Harvey <tharvey@gateworks.com>
----
- drivers/net/ethernet/cavium/thunder/thunder_bgx.c | 13 +++++++---
- drivers/net/ethernet/cavium/thunder/thunder_bgx.h |  2 +-
- drivers/net/ethernet/cavium/thunder/thunder_xcv.c | 31 ++++++++++++++++++-----
- 3 files changed, 35 insertions(+), 11 deletions(-)
-
---- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
-+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
-@@ -55,6 +55,7 @@ struct bgx {
- 	struct pci_dev		*pdev;
- 	bool                    is_dlm;
- 	bool                    is_rgx;
-+	int			phy_mode;
- };
- 
- static struct bgx *bgx_vnic[MAX_BGX_THUNDER];
-@@ -841,12 +842,12 @@ static void bgx_poll_for_link(struct wor
- 	queue_delayed_work(lmac->check_link, &lmac->dwork, HZ * 2);
- }
- 
--static int phy_interface_mode(u8 lmac_type)
-+static int phy_interface_mode(struct bgx *bgx, u8 lmac_type)
- {
- 	if (lmac_type == BGX_MODE_QSGMII)
- 		return PHY_INTERFACE_MODE_QSGMII;
- 	if (lmac_type == BGX_MODE_RGMII)
--		return PHY_INTERFACE_MODE_RGMII;
-+		return bgx->phy_mode;
- 
- 	return PHY_INTERFACE_MODE_SGMII;
- }
-@@ -912,7 +913,8 @@ static int bgx_lmac_enable(struct bgx *b
- 
- 		if (phy_connect_direct(&lmac->netdev, lmac->phydev,
- 				       bgx_lmac_handler,
--				       phy_interface_mode(lmac->lmac_type)))
-+				       phy_interface_mode(bgx,
-+							  lmac->lmac_type)))
- 			return -ENODEV;
- 
- 		phy_start_aneg(lmac->phydev);
-@@ -1287,6 +1289,8 @@ static int bgx_init_of_phy(struct bgx *b
- 		bgx->lmac[lmac].lmacid = lmac;
- 
- 		phy_np = of_parse_phandle(node, "phy-handle", 0);
-+		if (phy_np)
-+			bgx->phy_mode = of_get_phy_mode(phy_np);
- 		/* If there is no phy or defective firmware presents
- 		 * this cortina phy, for which there is no driver
- 		 * support, ignore it.
-@@ -1390,7 +1394,6 @@ static int bgx_probe(struct pci_dev *pde
- 		bgx->max_lmac = 1;
- 		bgx->bgx_id = MAX_BGX_PER_CN81XX - 1;
- 		bgx_vnic[bgx->bgx_id] = bgx;
--		xcv_init_hw();
- 	}
- 
- 	/* On 81xx all are DLMs and on 83xx there are 3 BGX QLMs and one
-@@ -1407,6 +1410,8 @@ static int bgx_probe(struct pci_dev *pde
- 	if (err)
- 		goto err_enable;
- 
-+	if (bgx->is_rgx)
-+		xcv_init_hw(bgx->phy_mode);
- 	bgx_init_hw(bgx);
- 
- 	/* Enable all LMACs */
---- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
-+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
-@@ -226,7 +226,7 @@ void bgx_lmac_internal_loopback(int node
- void bgx_lmac_get_pfc(int node, int bgx_idx, int lmacid, void *pause);
- void bgx_lmac_set_pfc(int node, int bgx_idx, int lmacid, void *pause);
- 
--void xcv_init_hw(void);
-+void xcv_init_hw(int phy_mode);
- void xcv_setup_link(bool link_up, int link_speed);
- 
- u64 bgx_get_rx_stats(int node, int bgx_idx, int lmac, int idx);
---- a/drivers/net/ethernet/cavium/thunder/thunder_xcv.c
-+++ b/drivers/net/ethernet/cavium/thunder/thunder_xcv.c
-@@ -65,7 +65,7 @@ MODULE_LICENSE("GPL v2");
- MODULE_VERSION(DRV_VERSION);
- MODULE_DEVICE_TABLE(pci, xcv_id_table);
- 
--void xcv_init_hw(void)
-+void xcv_init_hw(int phy_mode)
- {
- 	u64  cfg;
- 
-@@ -81,12 +81,31 @@ void xcv_init_hw(void)
- 	/* Wait for DLL to lock */
- 	msleep(1);
- 
--	/* Configure DLL - enable or bypass
--	 * TX no bypass, RX bypass
--	 */
-+	/* enable/bypass DLL providing MAC based internal TX/RX delays */
- 	cfg = readq_relaxed(xcv->reg_base + XCV_DLL_CTL);
--	cfg &= ~0xFF03;
--	cfg |= CLKRX_BYP;
-+	cfg &= ~0xffff00;
-+	switch (phy_mode) {
-+	/* RX and TX delays are added by the MAC */
-+	case PHY_INTERFACE_MODE_RGMII:
-+		break;
-+	/* internal RX and TX delays provided by the PHY */
-+	case PHY_INTERFACE_MODE_RGMII_ID:
-+		cfg |= CLKRX_BYP;
-+		cfg |= CLKTX_BYP;
-+		break;
-+	/* internal RX delay provided by the PHY, the MAC
-+	 * should not add an RX delay in this case
-+	 */
-+	case PHY_INTERFACE_MODE_RGMII_RXID:
-+		cfg |= CLKRX_BYP;
-+		break;
-+	/* internal TX delay provided by the PHY, the MAC
-+	 * should not add an TX delay in this case
-+	 */
-+	case PHY_INTERFACE_MODE_RGMII_TXID:
-+		cfg |= CLKRX_BYP;
-+		break;
-+	}
- 	writeq_relaxed(cfg, xcv->reg_base + XCV_DLL_CTL);
- 
- 	/* Enable compensation controller and force the
diff --git a/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch b/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch
deleted file mode 100644
index ef7aef3a8a..0000000000
--- a/target/linux/rockchip-rk3328/patches-4.14/0001-net-thunderx-workaround-BGX-TX-Underflow-issue.patch
+++ /dev/null
@@ -1,110 +0,0 @@
-From b1e7791e688620c9bb8476ac2d0bc99abeb7f825 Mon Sep 17 00:00:00 2001
-From: Tim Harvey <tharvey@gateworks.com>
-Date: Fri, 29 Dec 2017 16:48:04 -0800
-Subject: [PATCH] net: thunderx: workaround BGX TX Underflow issue
-
-While it is not yet understood why a TX underflow can easily occur
-for SGMII interfaces resulting in a TX wedge. It has been found that
-disabling/re-enabling the LMAC resolves the issue.
-
-Signed-off-by: Tim Harvey <tharvey@gateworks.com>
----
- drivers/net/ethernet/cavium/thunder/thunder_bgx.c | 54 +++++++++++++++++++++++
- drivers/net/ethernet/cavium/thunder/thunder_bgx.h |  9 ++++
- 2 files changed, 63 insertions(+)
-
---- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
-+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
-@@ -1344,6 +1344,54 @@ static int bgx_init_phy(struct bgx *bgx)
- 	return bgx_init_of_phy(bgx);
- }
- 
-+static irqreturn_t bgx_intr_handler(int irq, void *data)
-+{
-+	struct bgx *bgx = (struct bgx *)data;
-+	struct device *dev = &bgx->pdev->dev;
-+	u64 status, val;
-+	int lmac;
-+
-+	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
-+		status = bgx_reg_read(bgx, lmac, BGX_GMP_GMI_TXX_INT);
-+		if (status & GMI_TXX_INT_UNDFLW) {
-+			dev_err(dev, "BGX%d lmac%d UNDFLW\n", bgx->bgx_id,
-+				lmac);
-+			val = bgx_reg_read(bgx, lmac, BGX_CMRX_CFG);
-+			val &= ~CMR_EN;
-+			bgx_reg_write(bgx, lmac, BGX_CMRX_CFG, val);
-+			val |= CMR_EN;
-+			bgx_reg_write(bgx, lmac, BGX_CMRX_CFG, val);
-+		}
-+		/* clear interrupts */
-+		bgx_reg_write(bgx, lmac, BGX_GMP_GMI_TXX_INT, status);
-+	}
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int bgx_register_intr(struct pci_dev *pdev)
-+{
-+	struct bgx *bgx = pci_get_drvdata(pdev);
-+	struct device *dev = &pdev->dev;
-+	int num_vec, ret;
-+	char irq_name[32];
-+
-+	/* Enable MSI-X */
-+	num_vec = pci_msix_vec_count(pdev);
-+	ret = pci_alloc_irq_vectors(pdev, num_vec, num_vec, PCI_IRQ_MSIX);
-+	if (ret < 0) {
-+		dev_err(dev, "Req for #%d msix vectors failed\n", num_vec);
-+		return 1;
-+	}
-+	sprintf(irq_name, "BGX%d", bgx->bgx_id);
-+	ret = request_irq(pci_irq_vector(pdev, GMPX_GMI_TX_INT),
-+		bgx_intr_handler, 0, irq_name, bgx);
-+	if (ret)
-+		return 1;
-+
-+	return 0;
-+}
-+
- static int bgx_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
- {
- 	int err;
-@@ -1414,6 +1462,8 @@ static int bgx_probe(struct pci_dev *pde
- 		xcv_init_hw(bgx->phy_mode);
- 	bgx_init_hw(bgx);
- 
-+	bgx_register_intr(pdev);
-+
- 	/* Enable all LMACs */
- 	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
- 		err = bgx_lmac_enable(bgx, lmac);
-@@ -1424,6 +1474,10 @@ static int bgx_probe(struct pci_dev *pde
- 				bgx_lmac_disable(bgx, --lmac);
- 			goto err_enable;
- 		}
-+
-+		/* enable TX FIFO Underflow interrupt */
-+		bgx_reg_modify(bgx, lmac, BGX_GMP_GMI_TXX_INT_ENA_W1S,
-+			       GMI_TXX_INT_UNDFLW);
- 	}
- 
- 	return 0;
---- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
-+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.h
-@@ -179,6 +179,15 @@
- #define BGX_GMP_GMI_TXX_BURST		0x38228
- #define BGX_GMP_GMI_TXX_MIN_PKT		0x38240
- #define BGX_GMP_GMI_TXX_SGMII_CTL	0x38300
-+#define BGX_GMP_GMI_TXX_INT		0x38500
-+#define BGX_GMP_GMI_TXX_INT_W1S		0x38508
-+#define BGX_GMP_GMI_TXX_INT_ENA_W1C	0x38510
-+#define BGX_GMP_GMI_TXX_INT_ENA_W1S	0x38518
-+#define  GMI_TXX_INT_PTP_LOST			BIT_ULL(4)
-+#define  GMI_TXX_INT_LATE_COL			BIT_ULL(3)
-+#define  GMI_TXX_INT_XSDEF			BIT_ULL(2)
-+#define  GMI_TXX_INT_XSCOL			BIT_ULL(1)
-+#define  GMI_TXX_INT_UNDFLW			BIT_ULL(0)
- 
- #define BGX_MSIX_VEC_0_29_ADDR		0x400000 /* +(0..29) << 4 */
- #define BGX_MSIX_VEC_0_29_CTL		0x400008
-- 
2.14.1.windows.1

